<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Rede 3D</title>
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Raleway', sans-serif;
            background-color: transparent; /* Fundo transparente */
        }
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: block;
            background-color: transparent; /* Fundo transparente para o container do jogo */
            touch-action: none; /* Prevenir ações padrão do navegador em toques */
        }
        #uiContainer {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.3); /* Fundo levemente escuro para legibilidade */
            color: white;
            border-radius: 8px;
            font-size: 14px;
            width: 200px; /* Largura fixa para o painel de UI */
            max-height: 90vh; /* Altura máxima para evitar cobrir toda a tela */
            overflow-y: auto; /* Scroll se o conteúdo exceder */
        }
        #uiContainer h3 {
            margin-top: 0;
            color: #FF7F00; /* Laranja para o título do placar */
        }
        #uiContainer p {
            margin: 5px 0;
        }
        .message {
            font-size: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            padding-bottom: 3px;
            margin-bottom: 3px;
        }
        .message:last-child {
            border-bottom: none;
        }
        #victoryMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background-color: rgba(0, 127, 255, 0.85); /* Azul para mensagem de vitória */
            color: white;
            font-size: 20px; 
            text-align: center;
            border-radius: 10px;
            display: none; /* Escondido inicialmente */
            z-index: 1000;
        }
        #victoryMessage p {
            font-size: 14px; /* Como solicitado para o texto interno */
            margin: 5px 0;
        }
        #playAgainButton {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 16px;
            font-family: 'Raleway', sans-serif;
            background-color: #FF7F00; /* Laranja */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #playAgainButton:hover {
            background-color: #E67300; /* Laranja mais escuro no hover */
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <div id="uiContainer">
        <h3>Placar</h3>
        <p id="playerScore">Jogador: 0</p>
        <p id="aiScore">IA: 0</p>
        <hr>
        <h4>Eventos:</h4>
        <div id="eventLog"></div>
    </div>
    <div id="victoryMessage">
        <h2 id="winnerTitle"></h2>
        <p id="finalPlayerScore"></p>
        <p id="finalAiScore"></p>
        <button id="playAgainButton">Jogar Novamente</button>
    </div>

    <script>
        // Configurações do Jogo
        const WINNING_SCORE = 150;
        const NODE_RADIUS = 0.6; 
        const AI_COLLECTION_INTERVAL = 2000; 
        const NODE_COLLECTABLE_TIME = 1000; 
        const NEW_NODES_ON_COLLECT = 3;
        const NODE_SIZE_INCREASE_FACTOR = 1.02; 

        // Cores
        const COLOR_IA_COLLECTED = 0xFFFF00;
        const COLOR_ORIGINAL_NODE = 0xFF7F00;
        const COLOR_PLAYER_COLLECTED = 0xFF007F;
        const COLOR_EDGE = 0xFFFFFF; 
        const COLOR_NODE_DEFAULT_MATERIAL = 0x007FFF; 

        let scene, camera, renderer, controls;
        let world; 
        
        let nodes = []; 
        let edges = []; 

        let playerScore = 0;
        let aiScore = 0;
        let gameRunning = true;
        let nextNodeId = 0;
        let lastAICheckTime = 0;

        // Elementos da UI
        const playerScoreDisplay = document.getElementById('playerScore');
        const aiScoreDisplay = document.getElementById('aiScore');
        const eventLog = document.getElementById('eventLog');
        const victoryMessageDiv = document.getElementById('victoryMessage');
        const winnerTitle = document.getElementById('winnerTitle');
        const finalPlayerScore = document.getElementById('finalPlayerScore');
        const finalAiScore = document.getElementById('finalAiScore');
        const playAgainButton = document.getElementById('playAgainButton');

        // Inicialização
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 30); 
            camera.lookAt(0,0,0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); 
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false; 
            controls.minDistance = 5; 
            controls.maxDistance = 250; 
            controls.target.set(0,0,0);

            controls.touches = {
                ONE: THREE.TOUCH.NONE !== undefined ? THREE.TOUCH.NONE : null, 
                TWO: THREE.TOUCH.DOLLY_ROTATE 
            };


            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            world = new CANNON.World();
            world.gravity.set(0, 0, 0); 
            world.broadphase = new CANNON.NaiveBroadphase(); 
            world.solver.iterations = 10; 

            const nodeMaterial = new CANNON.Material('nodeMaterial');
            const nodeContactMaterial = new CANNON.ContactMaterial(nodeMaterial, nodeMaterial, {
                friction: 0.1, 
                restitution: 0.5 
            });
            world.addContactMaterial(nodeContactMaterial);

            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onMouseClick, false);
            renderer.domElement.addEventListener('touchend', onTouchEnd, false);
            playAgainButton.addEventListener('click', resetGame);


            spawnInitialNode();
            animate();
        }

        function spawnInitialNode() {
            createNode(new THREE.Vector3(0, 0, 0), null); 
        }

        function createNode(position, parentNode = null) {
            const nodeId = nextNodeId++;
            
            const geometry = new THREE.SphereGeometry(NODE_RADIUS, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: COLOR_NODE_DEFAULT_MATERIAL });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData = { id: nodeId, type: 'node', collected: false, collectable: false, connections: 0, baseRadius: NODE_RADIUS };
            scene.add(mesh);

            const initialRadius = NODE_RADIUS; 
            const shape = new CANNON.Sphere(initialRadius); 
            const body = new CANNON.Body({
                mass: 0.8, 
                position: new CANNON.Vec3(position.x, position.y, position.z),
                material: world.materials.find(m => m.name === 'nodeMaterial') || new CANNON.Material('nodeMaterial')
            });
            body.addShape(shape);
            body.userData = mesh; 
            world.addBody(body);
            
            const nodeObject = { id: nodeId, mesh, body, parentNodeId: parentNode ? parentNode.id : null, connections: 0 };
            nodes.push(nodeObject);

            setTimeout(() => {
                if (nodeObject.mesh && !nodeObject.mesh.userData.collected) { // Checa se o mesh ainda existe
                    nodeObject.mesh.userData.collectable = true;
                    nodeObject.mesh.material.color.setHex(COLOR_ORIGINAL_NODE);
                }
            }, NODE_COLLECTABLE_TIME);

            if (parentNode) {
                createEdge(nodeObject, parentNode);
                incrementNodeConnections(nodeObject); 
                incrementNodeConnections(parentNode); 
            }
            
            return nodeObject;
        }

        function incrementNodeConnections(node) {
            node.connections++;
            node.mesh.userData.connections++;
            
            const scaleFactor = Math.pow(NODE_SIZE_INCREASE_FACTOR, node.connections);
            node.mesh.scale.set(scaleFactor, scaleFactor, scaleFactor);
            
            if (node.body.shapes.length > 0 && node.body.shapes[0] instanceof CANNON.Sphere) {
                node.body.shapes[0].radius = node.mesh.userData.baseRadius * scaleFactor; 
                node.body.updateBoundingRadius(); 
            }
        }


        function createEdge(node1, node2) {
            const material = new THREE.LineBasicMaterial({ color: COLOR_EDGE, linewidth: 2 });
            const geometry = new THREE.BufferGeometry().setFromPoints([node1.mesh.position, node2.mesh.position]);
            const line = new THREE.Line(geometry, material);
            scene.add(line);

            const desiredDistance = NODE_RADIUS * 5.0; 
            const constraint = new CANNON.DistanceConstraint(
                node1.body, 
                node2.body, 
                desiredDistance, 
                150 
            );
            world.addConstraint(constraint);

            const edgeObject = { line, constraint, node1Id: node1.id, node2Id: node2.id };
            edges.push(edgeObject);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseClick(event) {
            if (!gameRunning) return;
            const clickCoords = { x: event.clientX, y: event.clientY };
            performRaycast(clickCoords);
        }

        function onTouchEnd(event) {
            if (!gameRunning) return;
            if (event.changedTouches.length === 0) return;
            const touch = event.changedTouches[0];
            const touchCoords = { x: touch.clientX, y: touch.clientY };
            performRaycast(touchCoords);
        }

        function performRaycast(coords) {
            const vec = new THREE.Vector2();
            const raycaster = new THREE.Raycaster();

            vec.x = (coords.x / renderer.domElement.clientWidth) * 2 - 1;
            vec.y = -(coords.y / renderer.domElement.clientHeight) * 2 + 1;
            raycaster.setFromCamera(vec, camera);
            
            const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh), false); 

            if (intersects.length > 0) {
                const intersectedMesh = intersects[0].object; 
                if (intersectedMesh.userData.collectable && !intersectedMesh.userData.collected) {
                    collectNode(intersectedMesh.userData.id, 'Jogador');
                }
            }
        }


        function collectNode(nodeId, collector) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node || node.mesh.userData.collected) return;

            node.mesh.userData.collected = true;
            node.mesh.userData.collectable = false; 

            let collectionMessage = "";
            const spawnPositionBase = node.mesh.position.clone();
            const offsetMultiplier = 9; 

            if (collector === 'Jogador') {
                playerScore++;
                node.mesh.material.color.setHex(COLOR_PLAYER_COLLECTED);
                collectionMessage = `Jogador coletou nó ${nodeId}`;
            } else if (collector === 'IA') {
                aiScore++;
                node.mesh.material.color.setHex(COLOR_IA_COLLECTED);
                collectionMessage = `IA coletou nó ${nodeId}`;
            }

            for (let i = 0; i < NEW_NODES_ON_COLLECT; i++) {
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * offsetMultiplier, 
                    (Math.random() - 0.5) * offsetMultiplier, 
                    (Math.random() - 0.5) * offsetMultiplier
                );
                if (offset.lengthSq() < 0.1) offset.x += 0.5 * Math.sign(offset.x || 1); 
                createNode(spawnPositionBase.clone().add(offset), node);
            }

            addEventToLog(collectionMessage, collector.toLowerCase());
            updateScoreDisplay();
            checkWinCondition();
        }
        
        function addEventToLog(message, type) {
            const p = document.createElement('p');
            p.textContent = message;
            p.classList.add('message');
            if (type === 'jogador') p.style.color = `#${COLOR_PLAYER_COLLECTED.toString(16).padStart(6, '0')}`;
            if (type === 'ia') p.style.color = `#${COLOR_IA_COLLECTED.toString(16).padStart(6, '0')}`;
            
            eventLog.insertBefore(p, eventLog.firstChild); 
            if (eventLog.children.length > 10) { 
                eventLog.removeChild(eventLog.lastChild);
            }
        }

        function updateScoreDisplay() {
            playerScoreDisplay.textContent = `Jogador: ${playerScore}`;
            aiScoreDisplay.textContent = `IA: ${aiScore}`;
        }

        function aiTurn(currentTime) {
            if (!gameRunning || currentTime - lastAICheckTime < AI_COLLECTION_INTERVAL) return;
            lastAICheckTime = currentTime;

            const collectableNodes = nodes.filter(n => n.mesh.userData.collectable && !n.mesh.userData.collected);
            if (collectableNodes.length > 0) {
                collectableNodes.sort((a, b) => a.mesh.userData.connections - b.mesh.userData.connections);
                const nodeToCollect = collectableNodes[0];
                collectNode(nodeToCollect.id, 'IA');
            }
        }
        
        function applyForces() {
            const centerAttractionForce = 0.005; 
            const repulsionStrength = 4.0; 
            const minRepulsionDistance = NODE_RADIUS * 6.0; 

            for (let i = 0; i < nodes.length; i++) {
                const nodeA = nodes[i];
                if (!nodeA.body) continue; 
                
                const forceToCenter = nodeA.body.position.clone().negate().scale(centerAttractionForce * nodeA.body.mass);
                nodeA.body.applyForce(forceToCenter, nodeA.body.position);

                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeB = nodes[j];
                    if (!nodeB.body) continue; 
                    
                    const diff = new CANNON.Vec3();
                    nodeA.body.position.vsub(nodeB.body.position, diff);
                    const distance = diff.length();
                    
                    if (distance > 0.01 && distance < minRepulsionDistance) { 
                        const isConnected = edges.some(edge => 
                            (edge.node1Id === nodeA.id && edge.node2Id === nodeB.id) ||
                            (edge.node1Id === nodeB.id && edge.node2Id === nodeA.id)
                        );

                        if (!isConnected) { 
                            const forceMagnitude = repulsionStrength / (distance * distance + 0.01); 
                            diff.normalize();
                            const force = diff.scale(forceMagnitude);
                            nodeA.body.applyForce(force, nodeA.body.position);
                            nodeB.body.applyForce(force.negate(), nodeB.body.position); 
                        }
                    }
                }
            }
        }

        function checkWinCondition() {
            if (!gameRunning) return;
            let winner = null;
            if (playerScore >= WINNING_SCORE) winner = 'Jogador';
            else if (aiScore >= WINNING_SCORE) winner = 'IA';

            if (winner) {
                gameRunning = false;
                winnerTitle.textContent = `${winner} Venceu!`;
                finalPlayerScore.textContent = `Jogador: ${playerScore}`;
                finalAiScore.textContent = `IA: ${aiScore}`;
                victoryMessageDiv.style.display = 'block';
                if (winner === 'Jogador') {
                     victoryMessageDiv.style.backgroundColor = `#${COLOR_PLAYER_COLLECTED.toString(16).padStart(6, '0')}`;
                } else {
                     victoryMessageDiv.style.backgroundColor = `#${COLOR_IA_COLLECTED.toString(16).padStart(6, '0')}`;
                }
            }
        }

        function resetGame() {
            // Limpar nós da cena e do mundo físico
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                scene.remove(node.mesh);
                if (node.body) { // Checar se o corpo existe antes de remover
                    world.removeBody(node.body);
                }
            }
            nodes = [];

            // Limpar arestas da cena e do mundo físico
            for (let i = edges.length - 1; i >= 0; i--) {
                const edge = edges[i];
                scene.remove(edge.line);
                if (edge.constraint) { // Checar se a restrição existe
                     world.removeConstraint(edge.constraint);
                }
            }
            edges = [];

            // Resetar placares
            playerScore = 0;
            aiScore = 0;
            updateScoreDisplay();

            // Limpar log de eventos
            eventLog.innerHTML = '';

            // Resetar variáveis de controle
            nextNodeId = 0;
            lastAICheckTime = 0;
            
            // Esconder mensagem de vitória
            victoryMessageDiv.style.display = 'none';

            // Resetar câmera para posição inicial (opcional, mas pode ser bom)
            camera.position.set(0, 15, 30);
            camera.lookAt(0,0,0);
            controls.target.set(0,0,0);
            controls.update();

            // Recomeçar o jogo
            gameRunning = true;
            spawnInitialNode();
            // O loop de animação requestAnimationFrame(animate) já está rodando,
            // apenas gameRunning = true; reativa a lógica principal.
        }
        
        let lastTime = 0;
        function animate(currentTime = 0) {
            // Sempre requisitar o próximo frame para manter o loop de renderização e controles
            requestAnimationFrame(animate); 
            
            const deltaTime = (currentTime - lastTime) / 1000 || 1/60; 
            lastTime = currentTime;

            controls.update(); 

            // Apenas executa a lógica do jogo se gameRunning for true
            if (gameRunning) {
                 applyForces(); 
                 world.step(1 / 60, deltaTime, 3); 
                 aiTurn(currentTime);
            }

            // Sincronização e renderização ocorrem mesmo se o jogo estiver "pausado" (gameRunning = false)
            // para permitir que os controles da câmera funcionem e a cena seja exibida.
            for (const node of nodes) {
                if (node.mesh && node.body) { 
                    node.mesh.position.copy(node.body.position);
                    node.mesh.quaternion.copy(node.body.quaternion);
                }
            }

            for (const edge of edges) {
                const node1 = nodes.find(n => n.id === edge.node1Id);
                const node2 = nodes.find(n => n.id === edge.node2Id);
                if (node1 && node1.mesh && node2 && node2.mesh) { 
                    const pos1 = node1.mesh.position;
                    const pos2 = node2.mesh.position;
                    const positions = edge.line.geometry.attributes.position;
                    positions.setXYZ(0, pos1.x, pos1.y, pos1.z);
                    positions.setXYZ(1, pos2.x, pos2.y, pos2.z);
                    positions.needsUpdate = true;
                }
            }
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
